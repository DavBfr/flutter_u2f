// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// HidApi bindings for Linux and macOS
class Api {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Api(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Api.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// @brief Initialize the HIDAPI library.
  ///
  /// This function initializes the HIDAPI library. Calling it is not
  /// strictly necessary, as it will be called automatically by
  /// hid_enumerate() and any of the hid_open_*() functions if it is
  /// needed.  This function should be called at the beginning of
  /// execution however, if there is a chance of HIDAPI handles
  /// being opened by different threads simultaneously.
  ///
  /// @ingroup API
  ///
  /// @returns
  /// This function returns 0 on success and -1 on error.
  /// Call hid_error(NULL) to get the failure reason.
  int init() {
    return _init();
  }

  late final _initPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('hid_init');
  late final _init = _initPtr.asFunction<int Function()>();

  /// @brief Finalize the HIDAPI library.
  ///
  /// This function frees all of the static data associated with
  /// HIDAPI. It should be called at the end of execution to avoid
  /// memory leaks.
  ///
  /// @ingroup API
  ///
  /// @returns
  /// This function returns 0 on success and -1 on error.
  int exit() {
    return _exit();
  }

  late final _exitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('hid_exit');
  late final _exit = _exitPtr.asFunction<int Function()>();

  /// @brief Enumerate the HID Devices.
  ///
  /// This function returns a linked list of all the HID devices
  /// attached to the system which match vendor_id and product_id.
  /// If @p vendor_id is set to 0 then any vendor matches.
  /// If @p product_id is set to 0 then any product matches.
  /// If @p vendor_id and @p product_id are both set to 0, then
  /// all HID devices will be returned.
  ///
  /// @ingroup API
  /// @param vendor_id The Vendor ID (VID) of the types of device
  /// to open.
  /// @param product_id The Product ID (PID) of the types of
  /// device to open.
  ///
  /// @returns
  /// This function returns a pointer to a linked list of type
  /// struct #hid_device_info, containing information about the HID devices
  /// attached to the system,
  /// or NULL in the case of failure or if no HID devices present in the system.
  /// Call hid_error(NULL) to get the failure reason.
  ///
  /// @note The returned value by this function must to be freed by calling hid_free_enumeration(),
  /// when not needed anymore.
  ffi.Pointer<hid_device_info> enumerate(
    int vendor_id,
    int product_id,
  ) {
    return _enumerate(
      vendor_id,
      product_id,
    );
  }

  late final _enumeratePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<hid_device_info> Function(
              ffi.UnsignedShort, ffi.UnsignedShort)>>('hid_enumerate');
  late final _enumerate = _enumeratePtr
      .asFunction<ffi.Pointer<hid_device_info> Function(int, int)>();

  /// @brief Free an enumeration Linked List
  ///
  /// This function frees a linked list created by hid_enumerate().
  ///
  /// @ingroup API
  /// @param devs Pointer to a list of struct_device returned from
  /// hid_enumerate().
  void free_enumeration(
    ffi.Pointer<hid_device_info> devs,
  ) {
    return _free_enumeration(
      devs,
    );
  }

  late final _free_enumerationPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<hid_device_info>)>>(
      'hid_free_enumeration');
  late final _free_enumeration = _free_enumerationPtr
      .asFunction<void Function(ffi.Pointer<hid_device_info>)>();

  /// @brief Open a HID device using a Vendor ID (VID), Product ID
  /// (PID) and optionally a serial number.
  ///
  /// If @p serial_number is NULL, the first device with the
  /// specified VID and PID is opened.
  ///
  /// @ingroup API
  /// @param vendor_id The Vendor ID (VID) of the device to open.
  /// @param product_id The Product ID (PID) of the device to open.
  /// @param serial_number The Serial Number of the device to open
  /// (Optionally NULL).
  ///
  /// @returns
  /// This function returns a pointer to a #hid_device object on
  /// success or NULL on failure.
  /// Call hid_error(NULL) to get the failure reason.
  ///
  /// @note The returned object must be freed by calling hid_close(),
  /// when not needed anymore.
  ffi.Pointer<hid_device> open(
    int vendor_id,
    int product_id,
    ffi.Pointer<ffi.WChar> serial_number,
  ) {
    return _open(
      vendor_id,
      product_id,
      serial_number,
    );
  }

  late final _openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<hid_device> Function(ffi.UnsignedShort, ffi.UnsignedShort,
              ffi.Pointer<ffi.WChar>)>>('hid_open');
  late final _open = _openPtr.asFunction<
      ffi.Pointer<hid_device> Function(int, int, ffi.Pointer<ffi.WChar>)>();

  /// @brief Open a HID device by its path name.
  ///
  /// The path name be determined by calling hid_enumerate(), or a
  /// platform-specific path name can be used (eg: /dev/hidraw0 on
  /// Linux).
  ///
  /// @ingroup API
  /// @param path The path name of the device to open
  ///
  /// @returns
  /// This function returns a pointer to a #hid_device object on
  /// success or NULL on failure.
  /// Call hid_error(NULL) to get the failure reason.
  ///
  /// @note The returned object must be freed by calling hid_close(),
  /// when not needed anymore.
  ffi.Pointer<hid_device> open_path(
    ffi.Pointer<ffi.Char> path,
  ) {
    return _open_path(
      path,
    );
  }

  late final _open_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<hid_device> Function(
              ffi.Pointer<ffi.Char>)>>('hid_open_path');
  late final _open_path = _open_pathPtr
      .asFunction<ffi.Pointer<hid_device> Function(ffi.Pointer<ffi.Char>)>();

  /// @brief Write an Output report to a HID device.
  ///
  /// The first byte of @p data[] must contain the Report ID. For
  /// devices which only support a single report, this must be set
  /// to 0x0. The remaining bytes contain the report data. Since
  /// the Report ID is mandatory, calls to hid_write() will always
  /// contain one more byte than the report contains. For example,
  /// if a hid report is 16 bytes long, 17 bytes must be passed to
  /// hid_write(), the Report ID (or 0x0, for devices with a
  /// single report), followed by the report data (16 bytes). In
  /// this example, the length passed in would be 17.
  ///
  /// hid_write() will send the data on the first OUT endpoint, if
  /// one exists. If it does not, it will send the data through
  /// the Control Endpoint (Endpoint 0).
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param data The data to send, including the report number as
  /// the first byte.
  /// @param length The length in bytes of the data to send.
  ///
  /// @returns
  /// This function returns the actual number of bytes written and
  /// -1 on error.
  /// Call hid_error(dev) to get the failure reason.
  int write(
    ffi.Pointer<hid_device> dev,
    ffi.Pointer<ffi.UnsignedChar> data,
    int length,
  ) {
    return _write(
      dev,
      data,
      length,
    );
  }

  late final _writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<hid_device>,
              ffi.Pointer<ffi.UnsignedChar>, ffi.Size)>>('hid_write');
  late final _write = _writePtr.asFunction<
      int Function(
          ffi.Pointer<hid_device>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// @brief Read an Input report from a HID device with timeout.
  ///
  /// Input reports are returned
  /// to the host through the INTERRUPT IN endpoint. The first byte will
  /// contain the Report number if the device uses numbered reports.
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param data A buffer to put the read data into.
  /// @param length The number of bytes to read. For devices with
  /// multiple reports, make sure to read an extra byte for
  /// the report number.
  /// @param milliseconds timeout in milliseconds or -1 for blocking wait.
  ///
  /// @returns
  /// This function returns the actual number of bytes read and
  /// -1 on error.
  /// Call hid_error(dev) to get the failure reason.
  /// If no packet was available to be read within
  /// the timeout period, this function returns 0.
  int read_timeout(
    ffi.Pointer<hid_device> dev,
    ffi.Pointer<ffi.UnsignedChar> data,
    int length,
    int milliseconds,
  ) {
    return _read_timeout(
      dev,
      data,
      length,
      milliseconds,
    );
  }

  late final _read_timeoutPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<hid_device>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size,
              ffi.Int)>>('hid_read_timeout');
  late final _read_timeout = _read_timeoutPtr.asFunction<
      int Function(
          ffi.Pointer<hid_device>, ffi.Pointer<ffi.UnsignedChar>, int, int)>();

  /// @brief Read an Input report from a HID device.
  ///
  /// Input reports are returned
  /// to the host through the INTERRUPT IN endpoint. The first byte will
  /// contain the Report number if the device uses numbered reports.
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param data A buffer to put the read data into.
  /// @param length The number of bytes to read. For devices with
  /// multiple reports, make sure to read an extra byte for
  /// the report number.
  ///
  /// @returns
  /// This function returns the actual number of bytes read and
  /// -1 on error.
  /// Call hid_error(dev) to get the failure reason.
  /// If no packet was available to be read and
  /// the handle is in non-blocking mode, this function returns 0.
  int read(
    ffi.Pointer<hid_device> dev,
    ffi.Pointer<ffi.UnsignedChar> data,
    int length,
  ) {
    return _read(
      dev,
      data,
      length,
    );
  }

  late final _readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<hid_device>,
              ffi.Pointer<ffi.UnsignedChar>, ffi.Size)>>('hid_read');
  late final _read = _readPtr.asFunction<
      int Function(
          ffi.Pointer<hid_device>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// @brief Set the device handle to be non-blocking.
  ///
  /// In non-blocking mode calls to hid_read() will return
  /// immediately with a value of 0 if there is no data to be
  /// read. In blocking mode, hid_read() will wait (block) until
  /// there is data to read before returning.
  ///
  /// Nonblocking can be turned on and off at any time.
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param nonblock enable or not the nonblocking reads
  /// - 1 to enable nonblocking
  /// - 0 to disable nonblocking.
  ///
  /// @returns
  /// This function returns 0 on success and -1 on error.
  /// Call hid_error(dev) to get the failure reason.
  int set_nonblocking(
    ffi.Pointer<hid_device> dev,
    int nonblock,
  ) {
    return _set_nonblocking(
      dev,
      nonblock,
    );
  }

  late final _set_nonblockingPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<hid_device>, ffi.Int)>>(
      'hid_set_nonblocking');
  late final _set_nonblocking = _set_nonblockingPtr
      .asFunction<int Function(ffi.Pointer<hid_device>, int)>();

  /// @brief Send a Feature report to the device.
  ///
  /// Feature reports are sent over the Control endpoint as a
  /// Set_Report transfer.  The first byte of @p data[] must
  /// contain the Report ID. For devices which only support a
  /// single report, this must be set to 0x0. The remaining bytes
  /// contain the report data. Since the Report ID is mandatory,
  /// calls to hid_send_feature_report() will always contain one
  /// more byte than the report contains. For example, if a hid
  /// report is 16 bytes long, 17 bytes must be passed to
  /// hid_send_feature_report(): the Report ID (or 0x0, for
  /// devices which do not use numbered reports), followed by the
  /// report data (16 bytes). In this example, the length passed
  /// in would be 17.
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param data The data to send, including the report number as
  /// the first byte.
  /// @param length The length in bytes of the data to send, including
  /// the report number.
  ///
  /// @returns
  /// This function returns the actual number of bytes written and
  /// -1 on error.
  /// Call hid_error(dev) to get the failure reason.
  int send_feature_report(
    ffi.Pointer<hid_device> dev,
    ffi.Pointer<ffi.UnsignedChar> data,
    int length,
  ) {
    return _send_feature_report(
      dev,
      data,
      length,
    );
  }

  late final _send_feature_reportPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<hid_device>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size)>>('hid_send_feature_report');
  late final _send_feature_report = _send_feature_reportPtr.asFunction<
      int Function(
          ffi.Pointer<hid_device>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// @brief Get a feature report from a HID device.
  ///
  /// Set the first byte of @p data[] to the Report ID of the
  /// report to be read.  Make sure to allow space for this
  /// extra byte in @p data[]. Upon return, the first byte will
  /// still contain the Report ID, and the report data will
  /// start in data[1].
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param data A buffer to put the read data into, including
  /// the Report ID. Set the first byte of @p data[] to the
  /// Report ID of the report to be read, or set it to zero
  /// if your device does not use numbered reports.
  /// @param length The number of bytes to read, including an
  /// extra byte for the report ID. The buffer can be longer
  /// than the actual report.
  ///
  /// @returns
  /// This function returns the number of bytes read plus
  /// one for the report ID (which is still in the first
  /// byte), or -1 on error.
  /// Call hid_error(dev) to get the failure reason.
  int get_feature_report(
    ffi.Pointer<hid_device> dev,
    ffi.Pointer<ffi.UnsignedChar> data,
    int length,
  ) {
    return _get_feature_report(
      dev,
      data,
      length,
    );
  }

  late final _get_feature_reportPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<hid_device>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size)>>('hid_get_feature_report');
  late final _get_feature_report = _get_feature_reportPtr.asFunction<
      int Function(
          ffi.Pointer<hid_device>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// @brief Get a input report from a HID device.
  ///
  /// Since version 0.10.0, @ref HID_API_VERSION >= HID_API_MAKE_VERSION(0, 10, 0)
  ///
  /// Set the first byte of @p data[] to the Report ID of the
  /// report to be read. Make sure to allow space for this
  /// extra byte in @p data[]. Upon return, the first byte will
  /// still contain the Report ID, and the report data will
  /// start in data[1].
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param data A buffer to put the read data into, including
  /// the Report ID. Set the first byte of @p data[] to the
  /// Report ID of the report to be read, or set it to zero
  /// if your device does not use numbered reports.
  /// @param length The number of bytes to read, including an
  /// extra byte for the report ID. The buffer can be longer
  /// than the actual report.
  ///
  /// @returns
  /// This function returns the number of bytes read plus
  /// one for the report ID (which is still in the first
  /// byte), or -1 on error.
  /// Call hid_error(dev) to get the failure reason.
  int get_input_report(
    ffi.Pointer<hid_device> dev,
    ffi.Pointer<ffi.UnsignedChar> data,
    int length,
  ) {
    return _get_input_report(
      dev,
      data,
      length,
    );
  }

  late final _get_input_reportPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<hid_device>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size)>>('hid_get_input_report');
  late final _get_input_report = _get_input_reportPtr.asFunction<
      int Function(
          ffi.Pointer<hid_device>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// @brief Close a HID device.
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  void close(
    ffi.Pointer<hid_device> dev,
  ) {
    return _close(
      dev,
    );
  }

  late final _closePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<hid_device>)>>(
          'hid_close');
  late final _close =
      _closePtr.asFunction<void Function(ffi.Pointer<hid_device>)>();

  /// @brief Get The Manufacturer String from a HID device.
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param string A wide string buffer to put the data into.
  /// @param maxlen The length of the buffer in multiples of wchar_t.
  ///
  /// @returns
  /// This function returns 0 on success and -1 on error.
  /// Call hid_error(dev) to get the failure reason.
  int get_manufacturer_string(
    ffi.Pointer<hid_device> dev,
    ffi.Pointer<ffi.WChar> string,
    int maxlen,
  ) {
    return _get_manufacturer_string(
      dev,
      string,
      maxlen,
    );
  }

  late final _get_manufacturer_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<hid_device>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('hid_get_manufacturer_string');
  late final _get_manufacturer_string = _get_manufacturer_stringPtr.asFunction<
      int Function(ffi.Pointer<hid_device>, ffi.Pointer<ffi.WChar>, int)>();

  /// @brief Get The Product String from a HID device.
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param string A wide string buffer to put the data into.
  /// @param maxlen The length of the buffer in multiples of wchar_t.
  ///
  /// @returns
  /// This function returns 0 on success and -1 on error.
  /// Call hid_error(dev) to get the failure reason.
  int get_product_string(
    ffi.Pointer<hid_device> dev,
    ffi.Pointer<ffi.WChar> string,
    int maxlen,
  ) {
    return _get_product_string(
      dev,
      string,
      maxlen,
    );
  }

  late final _get_product_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<hid_device>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('hid_get_product_string');
  late final _get_product_string = _get_product_stringPtr.asFunction<
      int Function(ffi.Pointer<hid_device>, ffi.Pointer<ffi.WChar>, int)>();

  /// @brief Get The Serial Number String from a HID device.
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param string A wide string buffer to put the data into.
  /// @param maxlen The length of the buffer in multiples of wchar_t.
  ///
  /// @returns
  /// This function returns 0 on success and -1 on error.
  /// Call hid_error(dev) to get the failure reason.
  int get_serial_number_string(
    ffi.Pointer<hid_device> dev,
    ffi.Pointer<ffi.WChar> string,
    int maxlen,
  ) {
    return _get_serial_number_string(
      dev,
      string,
      maxlen,
    );
  }

  late final _get_serial_number_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<hid_device>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('hid_get_serial_number_string');
  late final _get_serial_number_string =
      _get_serial_number_stringPtr.asFunction<
          int Function(ffi.Pointer<hid_device>, ffi.Pointer<ffi.WChar>, int)>();

  /// @brief Get The struct #hid_device_info from a HID device.
  ///
  /// Since version 0.13.0, @ref HID_API_VERSION >= HID_API_MAKE_VERSION(0, 13, 0)
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  ///
  /// @returns
  /// This function returns a pointer to the struct #hid_device_info
  /// for this hid_device, or NULL in the case of failure.
  /// Call hid_error(dev) to get the failure reason.
  /// This struct is valid until the device is closed with hid_close().
  ///
  /// @note The returned object is owned by the @p dev, and SHOULD NOT be freed by the user.
  ffi.Pointer<hid_device_info> get_device_info(
    ffi.Pointer<hid_device> dev,
  ) {
    return _get_device_info(
      dev,
    );
  }

  late final _get_device_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<hid_device_info> Function(
              ffi.Pointer<hid_device>)>>('hid_get_device_info');
  late final _get_device_info = _get_device_infoPtr.asFunction<
      ffi.Pointer<hid_device_info> Function(ffi.Pointer<hid_device>)>();

  /// @brief Get a string from a HID device, based on its string index.
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param string_index The index of the string to get.
  /// @param string A wide string buffer to put the data into.
  /// @param maxlen The length of the buffer in multiples of wchar_t.
  ///
  /// @returns
  /// This function returns 0 on success and -1 on error.
  /// Call hid_error(dev) to get the failure reason.
  int get_indexed_string(
    ffi.Pointer<hid_device> dev,
    int string_index,
    ffi.Pointer<ffi.WChar> string,
    int maxlen,
  ) {
    return _get_indexed_string(
      dev,
      string_index,
      string,
      maxlen,
    );
  }

  late final _get_indexed_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<hid_device>, ffi.Int,
              ffi.Pointer<ffi.WChar>, ffi.Size)>>('hid_get_indexed_string');
  late final _get_indexed_string = _get_indexed_stringPtr.asFunction<
      int Function(
          ffi.Pointer<hid_device>, int, ffi.Pointer<ffi.WChar>, int)>();

  /// @brief Get a report descriptor from a HID device.
  ///
  /// Since version 0.14.0, @ref HID_API_VERSION >= HID_API_MAKE_VERSION(0, 14, 0)
  ///
  /// User has to provide a preallocated buffer where descriptor will be copied to.
  /// The recommended size for preallocated buffer is @ref HID_API_MAX_REPORT_DESCRIPTOR_SIZE bytes.
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open().
  /// @param buf The buffer to copy descriptor into.
  /// @param buf_size The size of the buffer in bytes.
  ///
  /// @returns
  /// This function returns non-negative number of bytes actually copied, or -1 on error.
  int get_report_descriptor(
    ffi.Pointer<hid_device> dev,
    ffi.Pointer<ffi.UnsignedChar> buf,
    int buf_size,
  ) {
    return _get_report_descriptor(
      dev,
      buf,
      buf_size,
    );
  }

  late final _get_report_descriptorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<hid_device>,
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Size)>>('hid_get_report_descriptor');
  late final _get_report_descriptor = _get_report_descriptorPtr.asFunction<
      int Function(
          ffi.Pointer<hid_device>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// @brief Get a string describing the last error which occurred.
  ///
  /// This function is intended for logging/debugging purposes.
  ///
  /// This function guarantees to never return NULL.
  /// If there was no error in the last function call -
  /// the returned string clearly indicates that.
  ///
  /// Any HIDAPI function that can explicitly indicate an execution failure
  /// (e.g. by an error code, or by returning NULL) - may set the error string,
  /// to be returned by this function.
  ///
  /// Strings returned from hid_error() must not be freed by the user,
  /// i.e. owned by HIDAPI library.
  /// Device-specific error string may remain allocated at most until hid_close() is called.
  /// Global error string may remain allocated at most until hid_exit() is called.
  ///
  /// @ingroup API
  /// @param dev A device handle returned from hid_open(),
  /// or NULL to get the last non-device-specific error
  /// (e.g. for errors in hid_open() or hid_enumerate()).
  ///
  /// @returns
  /// A string describing the last error (if any).
  ffi.Pointer<ffi.WChar> error(
    ffi.Pointer<hid_device> dev,
  ) {
    return _error(
      dev,
    );
  }

  late final _errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<hid_device>)>>('hid_error');
  late final _error = _errorPtr
      .asFunction<ffi.Pointer<ffi.WChar> Function(ffi.Pointer<hid_device>)>();

  /// @brief Get a runtime version of the library.
  ///
  /// This function is thread-safe.
  ///
  /// @ingroup API
  ///
  /// @returns
  /// Pointer to statically allocated struct, that contains version.
  ffi.Pointer<hid_api_version> version() {
    return _version();
  }

  late final _versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<hid_api_version> Function()>>(
          'hid_version');
  late final _version =
      _versionPtr.asFunction<ffi.Pointer<hid_api_version> Function()>();

  /// @brief Get a runtime version string of the library.
  ///
  /// This function is thread-safe.
  ///
  /// @ingroup API
  ///
  /// @returns
  /// Pointer to statically allocated string, that contains version string.
  ffi.Pointer<ffi.Char> version_str() {
    return _version_str();
  }

  late final _version_strPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'hid_version_str');
  late final _version_str =
      _version_strPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();
}

/// A structure to hold the version numbers.
final class hid_api_version extends ffi.Struct {
  /// < major version number
  @ffi.Int()
  external int major;

  /// < minor version number
  @ffi.Int()
  external int minor;

  /// < patch version number
  @ffi.Int()
  external int patch;
}

final class hid_device_ extends ffi.Opaque {}

/// @brief HID underlying bus types.
///
/// @ingroup API
abstract class hid_bus_type {
  /// Unknown bus type
  static const int HID_API_BUS_UNKNOWN = 0;

  /// USB bus
  /// Specifications:
  /// https://usb.org/hid
  static const int HID_API_BUS_USB = 1;

  /// Bluetooth or Bluetooth LE bus
  /// Specifications:
  /// https://www.bluetooth.com/specifications/specs/human-interface-device-profile-1-1-1/
  /// https://www.bluetooth.com/specifications/specs/hid-service-1-0/
  /// https://www.bluetooth.com/specifications/specs/hid-over-gatt-profile-1-0/
  static const int HID_API_BUS_BLUETOOTH = 2;

  /// I2C bus
  /// Specifications:
  /// https://docs.microsoft.com/previous-versions/windows/hardware/design/dn642101(v=vs.85)
  static const int HID_API_BUS_I2C = 3;

  /// SPI bus
  /// Specifications:
  /// https://www.microsoft.com/download/details.aspx?id=103325
  static const int HID_API_BUS_SPI = 4;
}

/// hidapi info structure
final class hid_device_info extends ffi.Struct {
  /// Platform-specific device path
  external ffi.Pointer<ffi.Char> path;

  /// Device Vendor ID
  @ffi.UnsignedShort()
  external int vendor_id;

  /// Device Product ID
  @ffi.UnsignedShort()
  external int product_id;

  /// Serial Number
  external ffi.Pointer<ffi.WChar> serial_number;

  /// Device Release Number in binary-coded decimal,
  /// also known as Device Version Number
  @ffi.UnsignedShort()
  external int release_number;

  /// Manufacturer String
  external ffi.Pointer<ffi.WChar> manufacturer_string;

  /// Product string
  external ffi.Pointer<ffi.WChar> product_string;

  /// Usage Page for this Device/Interface
  /// (Windows/Mac/hidraw only)
  @ffi.UnsignedShort()
  external int usage_page;

  /// Usage for this Device/Interface
  /// (Windows/Mac/hidraw only)
  @ffi.UnsignedShort()
  external int usage;

  /// The USB interface which this logical device
  /// represents.
  ///
  /// Valid only if the device is a USB HID device.
  /// Set to -1 in all other cases.
  @ffi.Int()
  external int interface_number;

  /// Pointer to the next device
  external ffi.Pointer<hid_device_info> next;

  /// Underlying bus type
  /// Since version 0.13.0, @ref HID_API_VERSION >= HID_API_MAKE_VERSION(0, 13, 0)
  @ffi.Int32()
  external int bus_type;
}

typedef hid_device = hid_device_;

const int HID_API_VERSION_MAJOR = 0;

const int HID_API_VERSION_MINOR = 14;

const int HID_API_VERSION_PATCH = 0;

const int HID_API_VERSION = 3584;

const String HID_API_VERSION_STR = '0.14.0';

const int HID_API_MAX_REPORT_DESCRIPTOR_SIZE = 4096;
